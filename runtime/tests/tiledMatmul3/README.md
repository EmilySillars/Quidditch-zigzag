# TiledMatmul3

## I. Input to ZigZag

#### a. MLIR (use linalg-to-stream tool)

```
  "func.func"() <{function_type = (memref<2048x2048xi8>, memref<2048x2048xi8, strided<[1, 2048]>>, memref<2048x2048xi32>) -> (), sym_name = "simple_matmul"}> ({
  ^bb0(%arg0: memref<2048x2048xi8>, %arg1: memref<2048x2048xi8, strided<[1, 2048]>>, %arg2: memref<2048x2048xi32>):
    %0 = "arith.constant"() <{value = 0 : i32}> : () -> i32
    "linalg.generic"(%arg0, %arg1, %0, %0, %arg2) <{indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> ()>, affine_map<(d0, d1, d2) -> ()>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = [#linalg.iterator_type<parallel>, #linalg.iterator_type<parallel>, #linalg.iterator_type<reduction>], operandSegmentSizes = array<i32: 4, 1>}> ({
    ^bb0(%arg3: i8, %arg4: i8, %arg5: i32, %arg6: i32, %arg7: i32):
      %1 = "arith.extsi"(%arg3) : (i8) -> i32
      %2 = "arith.subi"(%1, %arg5)  : (i32, i32) -> i32
      %3 = "arith.extsi"(%arg4) : (i8) -> i32
      %4 = "arith.subi"(%3, %arg6)  : (i32, i32) -> i32
      %5 = "arith.muli"(%2, %4)  : (i32, i32) -> i32
      %6 = "arith.addi"(%arg7, %5) : (i32, i32) -> i32
      "linalg.yield"(%6) : (i32) -> ()
    }) : (memref<2048x2048xi8>, memref<2048x2048xi8, strided<[1, 2048]>>, i32, i32, memref<2048x2048xi32>) -> ()
    "func.return"() : () -> ()
  }) {llvm.emit_c_interface}: () -> ()
```

#### b. Equivalent Python Workload Object? (directly passed to zigzag)

Need to double check if this workload object is correct!

```
workload = {
    0: {
        "operator_type": "default",
        "equation": "O[d0][d1] += I[d0][d2] * W[d2][d1]",
        "dimension_relations": [],
        "loop_dim_size": {"D0": 2048, "D1": 2048, "D2": 2048},
        "operand_precision": {"O": 32, "O_final": 32, "W": 8, "I": 8},
        "operand_source": {"W": [], "I": []},
        "constant_operands": ["I", "W"],
        "padding": {},
    }
}
```

workload generated by linalg-to-stream tool:

```
workload = {
    0: {
        "operator_type": "default",
        "equation": "O[d0][d1] += I[d0][d2] * W[d2][d1]",
        "dimension_relations": [],
        "loop_dim_size": {"D0": 2048, "D1": 2048, "D2": 2048},
        "operand_precision": {"O": 32, "O_final": 32, "W": 8, "I": 8},
        "operand_source": {"W": [], "I": []},
        "constant_operands": ["I", "W"],
        "padding": {"D0": (0, 0), "D2": (0, 0)},
    }
}
```

#### c. C code Equivalent (cannot feed to zigzag; just for reference)

C-ish pseudocode (ignoring sign extension and subtracting 0 instructions)

```
for d0; d0 < 2048; d0++:
for d1; d1 < 2048; d1++;
for d2; d2 < 2048; d2++;
  arg7[d0][d1] += arg3[d0][d2] * arg4[d2][d1]; // and this is a MAC!
```

## II. Output from ZigZag

```
==============================================================================
Temporal Loops                         O            W            I            
==============================================================================
for D0 in [0, 16):                     l3           l3           l3           
------------------------------------------------------------------------------
  for D0 in [0, 16):                   l3           l3           l3           
------------------------------------------------------------------------------
    for D1 in [0, 16):                 l3           l3           l1           
------------------------------------------------------------------------------
      for D1 in [0, 16):               l1           l3           l1           
------------------------------------------------------------------------------
        for D2 in [0, 16):             rf_32b_O     l3           l1           
------------------------------------------------------------------------------
          for D2 in [0, 16):           rf_32b_O     l1           l1           
------------------------------------------------------------------------------
==============================================================================
Spatial Loops                                                                 
==============================================================================
            parfor D1 in [0, 8):                                              
------------------------------------------------------------------------------
            parfor D0 in [0, 8):                                              
------------------------------------------------------------------------------
            parfor D2 in [0, 8):                                              
------------------------------------------------------------------------------

```

## III. Manual Transformation

reference:

```
void mlir_qmat_transformed(squareMat *a, squareMat *b, squareMat *c,
                           squareMat *dummy) {
  transposeSquareMat(b, dummy);
  // only square matrices allowed
  size_t d0_1_bk_sz = a->len / 4;
  size_t d1_1_bk_sz = a->len / 2;
  size_t d1_2_bk_sz = d1_1_bk_sz / 2;
  size_t d2_1_bk_sz = a->len / 2;

  for (size_t d0_1 = 0; d0_1 < 4; d0_1++) {
    for (size_t d0_2 = 0; d0_2 < 4; d0_2++) {
      for (size_t d1_1 = 0; d1_1 < 2; d1_1++) {
        for (size_t d1_2 = 0; d1_2 < 2; d1_2++) {
          for (size_t d1_3 = 0; d1_3 < 4; d1_3++) {
            for (size_t d2_1 = 0; d2_1 < 2; d2_1++) {
              for (size_t d2_2 = 0; d2_2 < 8;
                   d2_2++) { // technically spacially unrolled, but won't show
                             // that here
                size_t d0 = d0_1 * d0_1_bk_sz + d0_2;
                size_t d1 = d1_1 * d1_1_bk_sz + d1_2 * d1_2_bk_sz + d1_3;
                size_t d2 = d2_1 * d2_1_bk_sz + d2_2;
                c->mat[d0][d1] += a->mat[d0][d2] * b->mat[d2][d1];
              }
            }
          }
        }
      }
    }
  }
}
```



#### a. C code transformed

```
// 9 loops deep when ignoring spacial unrolling!!
void mlir_qmat_transformed(squareMat *a, squareMat *b, squareMat *c,
                           squareMat *dummy) {
  transposeSquareMat(b, dummy);
  // only square matrices allowed
  
  // D0 gets broken into 3 pieces, d0_1, d0_2, and d0_3. d0_3 refers to an elt, not a tile/block.
  size_t d0_1_bk_sz = a->len / 16;
  size_t d0_2_bk_sz = d0_1_bk_sz / 16;  
  
  // D1 gets broken into 3 pieces, d1_1, d1_2, and d1_3. d1_3 refers to an elt, not a tile/block.
  size_t d1_1_bk_sz = a->len / 16;
  size_t d1_2_bk_sz = d1_1_bk_sz / 16;  
  
  // D2 gets broken into 3 peices, d2_1, d2_2, and d2_3. d2_3 refers to an elt, not a tile/block.  
  size_t d2_1_bk_sz = a->len / 16;
  size_t d2_2_bk_sz = d2_1_bk_sz / 16;
  
  for (size_t d0_1 = 0; d_01 < 16; d0_1++) {
   for (size_t d0_2 = 0; d_02 < 16; d0_2++) {
    for (size_t d1_1 = 0; d1_1 < 16; d1_1++) {
     for (size_t d1_2 = 0; d1_2 < 16; d1_2++) {
      for (size_t d2_1 = 0; d2_1 < 16; d2_1++) {
       for (size_t d2_2 = 0; d2_2 < 16; d2_2++) {
        // the next three loops should be spacially unrolled, but we ignore that for now.
        for (d1_3 = 0; d1_3 < 8; d1_3++) {
         for (d0_3 = 0; d0_3 < 8; d0_3++) {
          for (d2_3 = 0; d2_3 < 8; d2_3++)
          
            // calculate indices
          	size_t d0 = (d0_1 * d0_1_bk_sz) + (d0_2 * d0_2_bk_sz) + d0_3.
          	size_t d1 = (d1_1 * d1_1_bk_sz) + (d1_2 * d1_2_bk_sz) + d1_3.
          	size_t d2 = (d2_1 * d2_1_bk_sz) + (d2_2 * d2_2_bk_sz) + d2_3.
          	
          	// MAC
          	c->mat[d0][d1] += a->mat[d0][d2] * b->mat[d2][d1];         
         }        
        }       
       }      
      }     
     }    
    }
   }
  }
}
```

#### b. MLIR transformed

```
todo
```

## IV. Running the transformed MLIR on Snitch

```
cd runtime/tests
```

spike: 
```
sh zigzag-spike-build-and-run.sh tiledMatmul3.mlir
```

verilator:
```
sh zigzag-verilator-build-and-run.sh tiledMatmul3.mlir
```


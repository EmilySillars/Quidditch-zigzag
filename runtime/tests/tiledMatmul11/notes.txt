// perform tiled matrix multiplication,
// dispatching part of the work to the accelerator!
  "func.func"() <{function_type = 
  (memref<104x104xi8>,                        // arg0 (input)
   memref<104x104xi8, strided<[1, 104]>>,     // arg1 (weight)
   memref<104x104xi32, strided<[104,1]>>,     // arg2 (output)
   memref<104x104xi32, strided<[104,1]>>,     // arg3 (output slice l1)
   memref<104x104xi8, strided<[1, 104]>>      // arg4 (weight slide l1)
  ) -> (), sym_name = "pineapple"}> ({
  ^bb0(%arg0: memref<104x104xi8>, 
       %arg1: memref<104x104xi8, strided<[1,104]>>, 
       %arg2: memref<104x104xi32, strided<[104,1]>>, 
       %l1OSlice: memref<104x104xi32, strided<[104,1]>>,
       %l1WSlice: memref<104x104xi8, strided<[1,104]>>):

    // indices
    %zero = arith.constant 0 : index
    %one = arith.constant 1: index
    %eight = arith.constant 8 : index
    %thirteen = arith.constant 13 : index  
    %oneOhFour = arith.constant 104 : index
    %d0_1_bk_sz = arith.constant 8 : index
    %b = arith.constant 0 : index
    // constants
    %zero_i32 = arith.constant 0: i32

    // enter scf FOR LOOP
    scf.for %d0_1 = %zero to %thirteen step %one iter_args() -> () { // this loop uses both L3 and L1

    %d0 = arith.muli %d0_1, %d0_1_bk_sz : index
	
	  // select a slice of output space on L3
    %outputTileL3 = memref.subview %arg2[%d0,%zero][8,104][1,1] 
    :  memref<104x104xi32, strided<[104,1]>> to memref<8x104xi32, strided<[104, 1], offset: ?>>

    // select a corresponding slice of output space on L1
    %outputTileL1 = memref.subview %l1OSlice[%zero,%zero][8,104][1,1] 
    :  memref<104x104xi32, strided<[104,1]>> to memref<8x104xi32, strided<[104, 1], offset: ?>>
    	
	  // select a slice of input data from L1
    %inputTile = memref.subview %arg0[%d0,%zero][8,104][1,1] 
    : memref<104x104xi8> to memref<8x104xi8, strided<[104, 1], offset: ?>>

    // dispatch mini matmul to accelerator
    func.call @dispatch_to_accelerator(%zero_i32, %inputTile, %arg1, %outputTileL1) 
    : (i32, memref<8x104xi8, strided<[104, 1], offset: ?>>, memref<104x104xi8, strided<[1,104]>>, memref<8x104xi32, strided<[104, 1], offset: ?>>) -> ()

    // copy L1 back to L3
    // memref.copy %outputTileL1, %outputTileL3 : 
    // memref<8x104xi32, strided<[104, 1], offset: ?>> to memref<8x104xi32, strided<[104, 1], offset: ?>>  

   func.call @memrefCopy32bit(%outputTileL1, %outputTileL3) : 
    (memref<8x104xi32, strided<[104, 1], offset: ?>>, memref<8x104xi32, strided<[104, 1], offset: ?>>) -> ()
    // OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO 
    // %widthTileL1 = memref.subview %arg1[%zero,%zero][8,104][1,1] 
    //  :  memref<104x104xi8, strided<[1,104]>> to memref<8x104xi8, strided<[1,104], offset: ?>>

    // // select weight data slice on L3
    // %widthTileL3 = memref.subview %arg1[%zero,%b][104,13][1,1] :
    // memref<104x104xi8, strided<[1,104]>> to memref<104x13xi8, strided<[1,104], offset: ?>>

    // %widthTileL33 = memref.subview %arg1[%zero,%b][8,104][1,1] :
    // memref<104x104xi8, strided<[1,104]>> to memref<8x104xi8, strided<[1,104], offset: ?>>

    // memref.copy %widthTileL1, %widthTileL33 : memref<8x104xi8, strided<[1,104], offset: ?>> 
    // to memref<8x104xi8, strided<[1,104], offset: ?>>

    // select a slice of output space on L3
    // %outputTileL33 = memref.subview %arg2[%d0,%zero][8,104][1,1] 
    // :  memref<104x104xi32, strided<[104,1]>> to memref<8x104xi32, strided<[104, 1], offset: ?>>

    // // select a corresponding slice of output space on L1
    // %outputTileL11 = memref.subview %l1OSlice[%zero,%zero][8,104][1,1] 
    // :  memref<104x104xi32, strided<[104,1]>> to memref<8x104xi32, strided<[104, 1], offset: ?>>

    // memref.copy %outputTileL11, %outputTileL33 : 
    // memref<8x104xi32, strided<[104, 1], offset: ?>> to 
    // memref<8x104xi32, strided<[104, 1], offset: ?>>  

    // memref.copy %outputTileL11, %outputTileL33 : 
    // memref<8x104xi32, strided<[104, 1], offset: ?>> to 
    // memref<8x104xi32, strided<[104, 1], offset: ?>>   

    %verticalSliceOL3 = memref.subview %arg2[%zero, %d0][104,13][1,1] 
    :  memref<104x104xi32, strided<[104,1]>> to memref<104x13xi32, strided<[104, 1], offset: ?>>

    %verticalSliceOL1 = memref.subview %l1OSlice[%zero,%zero][104,13][1,1]
    : memref<104x104xi32, strided<[104,1]>> to memref<104x13xi32, strided<[104, 1], offset: ?>>

    // memref.copy %verticalSliceOL1, %verticalSliceOL3 : 
    // memref<104x13xi32, strided<[104, 1], offset: ?>> to 
    // memref<104x13xi32, strided<[104, 1], offset: ?>> 

    // OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO 

    // zero-out the L1 slice; there has to be a better way to do this, right?
    scf.for %i = %zero to %eight step %one iter_args() -> () { 
    scf.for %j = %zero to %oneOhFour step %one iter_args() -> () { 
     memref.store %zero_i32, %outputTileL1[%i, %j] :memref<8x104xi32, strided<[104, 1], offset: ?>>
    } // end of %i for
    } // end of %j for
    } // end of d0_1 for
    "func.return"() : () -> ()
  }) {llvm.emit_c_interface}: () -> ()